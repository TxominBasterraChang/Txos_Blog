[
  {
    "objectID": "posts/Houses_Bilbao/Houses_Bilbao.html",
    "href": "posts/Houses_Bilbao/Houses_Bilbao.html",
    "title": "Houses in Bilbao",
    "section": "",
    "text": "library(tidyverse)\nlibrary(tidymodels)\nlibrary(readxl)\nlibrary(openxlsx)\nlibrary(lubridate)\nlibrary(here)\nlibrary(devtools)\nlibrary(recipes) \nlibrary(rsample)\nlibrary(timetk)\nlibrary(glmnet)\nlibrary(tidyquant)\nlibrary(visdat)\nlibrary(janitor)\nlibrary(kableExtra)\nlibrary(caret)\nlibrary(rpart)  \nlibrary(rpart.plot)\nlibrary(pdp)\nlibrary(vip)\nlibrary(GGally)\nlibrary(car)\nlibrary(ggcorrplot)\nlibrary(ggdensity)\nlibrary(tidyquant)\nlibrary(scico)\nlibrary(paletteer)\nlibrary(earth)\nlibrary(vip)\nlibrary(ranger)\nlibrary(h2o)\nlibrary(xgboost)\nlibrary(modeltime)\nlibrary(caret)\nlibrary(lares)\nlibrary(lmtest)\nlibrary(nortest)\nlibrary(auditor)\nlibrary(DALEXtra)\nlibrary(modelStudio)\nlibrary(patchwork)\nWhat determines the price of houses in Bilbao? I want to investigate this question using Kaggle’s Spanish Housing Dataset which was originally web-crawled from Idealista (between March-April 2019).\nKnowledge of the housing market is not only valuable for sellers and buyers of real estate but can also provide profound understanding of socio-economic and socio-demographic local variations within a city.\nBilbao is a city in northern Spain located in the province Bizkaia. It is the largest metropolitan area in the region and an economic and cultural hub.\nIn this analysis I will explore Bilbao’s housing market in search for an understanding of the driving factors of real estate prices."
  },
  {
    "objectID": "posts/Houses_Bilbao/Houses_Bilbao.html#splitting-the-data",
    "href": "posts/Houses_Bilbao/Houses_Bilbao.html#splitting-the-data",
    "title": "Houses in Bilbao",
    "section": "Splitting the Data",
    "text": "Splitting the Data\nFirst we split the data into a train and test set where 3/4 of the whole data is reserved for training and the rest for testing. We also use strata = \"price_m2\" to make sure that the distribution of price_m2 is equal between training and testing set.\n\nset.seed(123)\nsplit <- initial_split(Bilbao, prop = 0.75, \n                       strata = \"price_m2\")\ndata_train  <- training(split)\ndata_test   <- testing(split)"
  },
  {
    "objectID": "posts/Houses_Bilbao/Houses_Bilbao.html#missing-data",
    "href": "posts/Houses_Bilbao/Houses_Bilbao.html#missing-data",
    "title": "Houses in Bilbao",
    "section": "Missing Data",
    "text": "Missing Data\nThere is missing data. Because some models (like OLS) cannot handle NAs we will interpolate these using a KNN Algorithm.\n\nvis_miss(Bilbao, cluster = TRUE)"
  },
  {
    "objectID": "posts/Houses_Bilbao/Houses_Bilbao.html#create-a-recipe",
    "href": "posts/Houses_Bilbao/Houses_Bilbao.html#create-a-recipe",
    "title": "Houses in Bilbao",
    "section": "Create a Recipe",
    "text": "Create a Recipe\nThe function recipe() allows to preprocess the data before modeling. It can be applied to training and testing data. The advantage of uf using recipe() is that it avoids data leakage between data sets. Data leakage occurs when data transformation steps are processed on the entire data set before it is subdivided into training and testing splits. E.g., if a min-max transformation would be applied on the whole data set before splitting, the individual splits would be biased towards to global minimum and maximum. In a resampling and cross validation context, recipe() ensures that the data preprocessing is conducted after every iteration of data splitting.\n\nmodel_rec <- recipe(\n  price_m2 ~ .,\n  data= data_train) %>% \n  step_zv(all_predictors()) %>%\n  step_dummy(all_nominal()) %>%\n  step_impute_knn(all_predictors(), neighbors = 10) %>% \n  prep(training = data_train, retain=TRUE, verbose=TRUE)\n\noper 1 step zv [training] \noper 2 step dummy [training] \noper 3 step impute knn [training] \nThe retained training set is ~ 0.97 Mb  in memory.\n\ntrainSet.prep <- bake(model_rec, new_data = data_train, composition='matrix')\ntrainSet = as.data.frame((trainSet.prep))\n\ntestSet.prep<-bake(model_rec, new_data = data_test, composition='matrix')\ntestSet = as.data.frame((testSet.prep))"
  },
  {
    "objectID": "posts/Houses_Bilbao/Houses_Bilbao.html#initialize-models",
    "href": "posts/Houses_Bilbao/Houses_Bilbao.html#initialize-models",
    "title": "Houses in Bilbao",
    "section": "Initialize Models",
    "text": "Initialize Models\n\nmyControl = trainControl(method = 'cv', \n                         number = 10, \n                         repeats = 5,\n                         verboseIter = FALSE, \n                         savePredictions = TRUE,\n                         allowParallel = T)\n\n\nparallel_start(6)\n\nset.seed(174)\nLinear.Model = train(price_m2 ~., \n                     data = trainSet, \n                     metric = 'RMSE', \n                     method = 'lm',\n                     preProcess = c('center', 'scale'),\n                     trControl = myControl)\n\n\nset.seed(174)\nGlmnet.Model = train(price_m2 ~ ., \n                     data = trainSet , \n                     metric = 'RMSE', \n                     method = 'glmnet',\n                     preProcess = c('center', 'scale'), \n                     trControl = myControl)\n\n\nset.seed(174)\nRapid.Ranger = train(price_m2 ~ ., \n                     data = trainSet, \n                     metric = 'RMSE', \n                     method = 'ranger',\n                     preProcess = c('center', 'scale'),\n                     trControl = myControl)\n\n\nset.seed(174)\nBasic.Knn <- train(price_m2 ~ .,\n             method     = \"knn\",\n             tuneGrid   = expand.grid(k =1:3), \n             trControl  = myControl, \n             metric= \"RMSE\", \n             data = trainSet)\n\n\nset.seed(174)\nXgb.Super <- train(price_m2~.,\n                   method = \"xgbTree\", \n                   tuneLength = 4,\n                   trControl = myControl,\n                   metric= \"RMSE\", \n                   data = trainSet)\n\nparallel_stop()\n\n\nsuite.of.models = list(\"LINEAR.MODEL\" = Linear.Model,\n                       \"GLMNET.MODEL\" = Glmnet.Model, \n                       \"RANGER.QUEST\" = Rapid.Ranger, \n                       \"KNN.SIMPLE\" = Basic.Knn, \n                       \"XGB.SUPER\"= Xgb.Super)\n\nresamps = resamples(suite.of.models) \ndotplot(resamps, metric = 'RMSE')\n\n\n\n\nXGBoost perfomes best on the training data. Let’s test it on the test data."
  },
  {
    "objectID": "posts/Houses_Bilbao/Houses_Bilbao.html#testing-models-on-test-set",
    "href": "posts/Houses_Bilbao/Houses_Bilbao.html#testing-models-on-test-set",
    "title": "Houses in Bilbao",
    "section": "TESTING MODELS ON TEST SET",
    "text": "TESTING MODELS ON TEST SET\n\nEvaluate.Prediction <- function(model, model.label, testData, ytest, grid = NULL) {\n \n  #capture prediction time\n  ptm <- proc.time()\n  # use test data to make predictions\n  pred <- predict(model, testData)\n  tm <- proc.time() - ptm\n  \n  Pred.metric<- postResample(pred = pred, obs = ytest)\n  RMSE.test <- c(Pred.metric[[1]])\n  RSquared.test <- c(Pred.metric[[2]])\n  MAE.test <- c(Pred.metric[[3]])\n  \n  \n  Summarised.results = NULL\n  if (is.null(grid)) { \n    Summarised.results = data.frame(predictor = c(model.label) ,  RMSE = RMSE.test , RSquared = RSquared.test, MAE = MAE.test, time = c(tm[[3]]))\n  } else {\n    .grid = data.frame(predictor = c(model.label) , RMSE = RMSE.test , RSquared = RSquared.test, MAE = MAE.test, time = c(tm[[3]]))\n    Summarised.results = rbind(grid, .grid)}\n  \n  \n  Summarised.results }\n\n\nMETRIC.GRID <- Evaluate.Prediction (Rapid.Ranger, \"RAPID.QUEST\", testSet, testSet$price_m2, grid=NULL)\n\nMETRIC.GRID <- Evaluate.Prediction (Glmnet.Model, \"GLMNET.MODEL\", testSet, testSet$price_m2, grid=METRIC.GRID)\n\nMETRIC.GRID <- Evaluate.Prediction (Basic.Knn, \"KNN.SIMPLE\", testSet, testSet$price_m2, grid=METRIC.GRID)\n\nMETRIC.GRID <- Evaluate.Prediction (Linear.Model, \"LINEAR.MODEL\", testSet, testSet$price_m2, grid=METRIC.GRID)\n\nMETRIC.GRID <- Evaluate.Prediction (Xgb.Super, \"XGB.SUPER\", testSet, testSet$price_m2, grid=METRIC.GRID)\n\n\nkable(METRIC.GRID[order(METRIC.GRID$RMSE, decreasing=F),]) %>% \n  kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\"))\n\n\n\n \n  \n      \n    predictor \n    RMSE \n    RSquared \n    MAE \n    time \n  \n \n\n  \n    5 \n    XGB.SUPER \n    773.6237 \n    0.6066140 \n    576.2671 \n    0.035 \n  \n  \n    1 \n    RAPID.QUEST \n    805.4272 \n    0.5733575 \n    584.3447 \n    0.032 \n  \n  \n    2 \n    GLMNET.MODEL \n    822.0240 \n    0.5559522 \n    607.2007 \n    0.013 \n  \n  \n    4 \n    LINEAR.MODEL \n    822.3261 \n    0.5553493 \n    607.3631 \n    0.006 \n  \n  \n    3 \n    KNN.SIMPLE \n    1023.4154 \n    0.3434201 \n    720.6059 \n    0.063 \n  \n\n\n\n\n\nAlso here, XGBoost has the smallest RMSE and highest R2. Let’s tune this model for further examination."
  },
  {
    "objectID": "posts/Houses_Bilbao/Houses_Bilbao.html#preprocessing",
    "href": "posts/Houses_Bilbao/Houses_Bilbao.html#preprocessing",
    "title": "Houses in Bilbao",
    "section": "Preprocessing",
    "text": "Preprocessing\nFirst we start again by dividing the data into training and testing samples. Again, we use price_m2 as a strata to ensure that the distribution of the response is eqaul between the testing and training sets. Then we create a recipe.\n\nset.seed(123)\nsplit <- initial_split(Bilbao, prop = 0.75, \n                       strata = \"price_m2\")\ndata_train  <- training(split)\ndata_test   <- testing(split)\n\nXGB_rec <- recipe(\n  price_m2 ~ .,\n  data= data_train) %>% \n  step_zv(all_predictors()) %>%\n  step_dummy(all_nominal()) %>%\n  step_impute_knn(all_predictors(), neighbors = 10) %>% \n  prep()\n\nApply pre-processing to randomly divide train data in subsets.\n\nset.seed(123)\ncv_folds <-recipes::bake(\n    XGB_rec, \n    new_data = data_train)%>%  \n  rsample::vfold_cv(v = 5)\n\ntrain.ready<-juice(XGB_rec)\ntest.ready<-bake(XGB_rec, new_data = data_test)"
  },
  {
    "objectID": "posts/Houses_Bilbao/Houses_Bilbao.html#modelling-specifications",
    "href": "posts/Houses_Bilbao/Houses_Bilbao.html#modelling-specifications",
    "title": "Houses in Bilbao",
    "section": "Modelling specifications",
    "text": "Modelling specifications\nDefine XGBoost modelling specifications and hyper parameters for tuning.\n\nModel.XGB <- \n  boost_tree(\n    mode = \"regression\",\n    trees = 1000,\n    min_n = tune(),\n    tree_depth = tune(),\n    learn_rate = tune(),\n    loss_reduction = tune()) %>% \n  set_engine(\"xgboost\", objective = \"reg:squarederror\")\n\n\nSpecify the model parameters\n\n# grid specification \nXGB.aspects <- \n  dials::parameters(\n    min_n(),\n    tree_depth(),\n    learn_rate(),\n    loss_reduction())\n\n\n\nGrid Space\nSet up a grid space which covers the hyper parameters XGB.aspects.\n\nxgboost_grid <- \ndials::grid_max_entropy(\nXGB.aspects, size = 200)\nkable(head(xgboost_grid))\n\n\n\n \n  \n    min_n \n    tree_depth \n    learn_rate \n    loss_reduction \n  \n \n\n  \n    19 \n    4 \n    0.0000000 \n    0.0024421 \n  \n  \n    15 \n    11 \n    0.0502801 \n    0.0000204 \n  \n  \n    38 \n    3 \n    0.0000000 \n    0.0000000 \n  \n  \n    7 \n    10 \n    0.0000001 \n    0.0002759 \n  \n  \n    38 \n    8 \n    0.0000000 \n    0.0000001 \n  \n  \n    37 \n    5 \n    0.0287556 \n    0.0000003 \n  \n\n\n\n\n\n\n\nCreate a workflow\n\nxgboost_wf <- \nworkflows::workflow() %>%\nadd_model(Model.XGB) %>% \nadd_formula(price_m2 ~ .)\n\n\n\nHyper parameter searching\nIn this step R searches for the optimal hyper parameters by iteratively applying the different hyper parameters to multiple training samples. This step can take a while to compute.\n\n'parallel_start(6)\n\nTUNE.XGB <- tune::tune_grid(\n  object = xgboost_wf,\n  resamples = cv_folds,\n  grid = xgboost_grid,\n  metrics = yardstick::metric_set(yardstick::rmse, yardstick::rsq, yardstick::rsq_trad, yardstick::mae),\n  control = tune::control_grid(verbose = FALSE)) \n\nparallel_stop()\n\nsaveRDS(TUNE.XGB, file = here(\"Data\", \"Tune_XGB.RData\"))'\n\n\n\nFinalize optimal tune\nExtract parameters with lowest RMSE.\n\nTUNE.XGB <- readRDS(here(\"Data\", \"Houses_Bilbao\",\"Tune_XGB.RData\"))\n\nparam_final <- TUNE.XGB %>%select_best(metric = \"rmse\")\n\nFinalize XGBoost with optimal tune.\n\nxgboost_wf2 <- xgboost_wf%>%\nfinalize_workflow(param_final)\n\n\n\nFit the final model\nFit final model on the preprocessed training data.\n\nXGB.model <- xgboost_wf2 %>%\nfit(train.ready)\n\nExtract important features.\n\nXGB.model %>% \n  pull_workflow_fit() %>% \n  vip()\n\n\n\n\nThe number of bathrooms, whether the appartment has a lift and the construction date seems to be the most important determinants for the square meter price.\n\n\nPredict on Test set.\nLet’s evaluate the XGBoost model on the test data by computing the RMSE.\n\n# use the training model fit to predict the test data\nXGB_res <- predict(XGB.model, new_data = test.ready %>% select(-price_m2))\n\nXGB_res <- bind_cols(XGB_res, test.ready %>% select(price_m2))\n\nXGB_metrics <- metric_set(yardstick::rmse, yardstick:: mae)\n\nkable(XGB_metrics(XGB_res, truth = price_m2, estimate = .pred))\n\n\n\n \n  \n    .metric \n    .estimator \n    .estimate \n  \n \n\n  \n    rmse \n    standard \n    799.5876 \n  \n  \n    mae \n    standard \n    590.3934 \n  \n\n\n\n\n\nWe can asses the fit of the pridiction by plotting them against the actual observations from the testing samples. We can see that the model works good up to 5000 Euro per square meter. For higher the model tends to underestimate the real prices.\n\nggplot(XGB_res, aes(x = price_m2, y = .pred)) + \n    # Create a diagonal line:\n    geom_abline(lty = 2) + \n    geom_point(alpha = 0.5) + \n    labs(y = \"Predicted Sale Price\", x = \"SalePrice\") +\n    # Scale and size the x- and y-axis uniformly:\n    coord_obs_pred() +\n  theme_minimal()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Txo’s Blog",
    "section": "",
    "text": "Fahrradaktivität in München (2008-2022)\n\n\nEine kurze Analyse\n\n\n\n\nMunich\n\n\nBike\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nApr 20, 2023\n\n\nTxomin Basterra Chang\n\n\n\n\n\n\n  \n\n\n\n\nHouses in Bilbao\n\n\nA little Investigation\n\n\n\n\nhousing\n\n\nSpain\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nApr 15, 2023\n\n\nTxomin Basterra Chang\n\n\n\n\n\n\n  \n\n\n\n\nCrimes in Chicago\n\n\nA little Investigation\n\n\n\n\nCrime\n\n\nChicago\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nFeb 25, 2023\n\n\nTxomin Basterra Chang\n\n\n\n\n\n\n  \n\n\n\n\nPolitics and the Press in Switzerland\n\n\nA little Historical investigation with R\n\n\n\n\nhistory\n\n\nSwitzerland\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nDec 16, 2022\n\n\nTxomin Basterra Chang\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Bike_Munich/Bike_Munich.html",
    "href": "posts/Bike_Munich/Bike_Munich.html",
    "title": "Fahrradaktivität in München (2008-2022)",
    "section": "",
    "text": "Auf dem Open Data Portal der Stadt München finden sich viele interessante Datensätze zu allen Möglichen Themen. Auf diesem befinden sich unteranderem die Daten der Raddauerzählstellen, welche eine herausragende Möglichkeiten bieten einen Einblick in die Fahrradaktivität in der Stadt München zu erlangen.\nDie Observationen werden an verschiedenen, innerhalb der City verteilten Zählstationen getätigt. Dabei wird im 15 Minuten Tackt gezählt wie viele Fahrradfahrerinnen innerhalb dieser Zeitspanne an der jeweilige\nBei dem Datensatz, den ich in dieser Analyse vorstellen werde handelt es sich um Tageswerte. Dabei werden die 15 minütigen Messungen auf den Tag kumuliert. Dieser Datensatz beinhalten neben der Fahrrad-Tagesaktivität auch Wetterdaten, wie etwa die Temperatur oder Sonnenstunden. Die Zeitreihe beginnt im Juni 2008 und läuft bis Dezember 2022."
  },
  {
    "objectID": "posts/Bike_Munich/Bike_Munich.html#fahrradaktivität-nach-zählstationen",
    "href": "posts/Bike_Munich/Bike_Munich.html#fahrradaktivität-nach-zählstationen",
    "title": "Fahrradaktivität in München (2008-2022)",
    "section": "Fahrradaktivität nach Zählstationen",
    "text": "Fahrradaktivität nach Zählstationen\nMünchen hat 6 Zählstation, welche über die Stadt verteilt sind. Wir sehen in der unteren Karte, dass die Stationen alle mehr oder weniger zentral gelegen sind. Nicht alle Stationen haben im selben Jahr angefangen zu messen. Mehr Informationen lassen sich durch das Klicken auf die Punkte herausfinden.\n\nload(here(\"Data\", \"Bike_Munich\",\"data_zaehl.Rda\"))\n\n mapview(data_zaehl, zcol = \"zaehlstelle\") \n\n\n\n\n\n\nDie untere Grafik zeigt auf wie sich die Aktivität der verschiedenen Stationen über die Jahre entwickelt hat. Wie bei der Gesamtaktivität lässt sich auch bei den meisten Zählstationen ein zyklisches Wachstum beobachten. Auffällig sind die Frequenzunterschiede zwischen den Stationen. In manchen ist scheint die Aktivität durchgehend höher zu sein als in anderen.\n\ndata %>%\n  group_by(datum, zaehlstelle) %>%\n  summarise(Gesamt = sum(gesamt), \n            Min.temp = mean(min.temp),\n            saison = saison) %>%\n  distinct() %>%\n  ggplot(aes(x = datum, y = Gesamt, color = zaehlstelle)) +\n  facet_wrap(~ zaehlstelle, ncol = 3) +\n  geom_line() +\n  ggtitle(\"Jahresentwicklung\") +\n  theme_minimal() +\n  theme(axis.title.x=element_blank())\n\n\n\n\nEbenfalls interessant sind Ausreißer wie etwa bei der Zählstation Olympia (zwischen den Jahren 2012 und 2015). Diese sind vermutlich durch das 24h Mountain Bike Rennen im Olympia Park erzeugt worden (Eine Analyse dazu findet sich in SOMTOMS Blog).\nDas Gesamtaktivitätsprofil lässt sich auch gut mit Boxplots darstellen. Die horizontal schraffierte Linie stellt den Gesamtmedian dar. Erhardt und Margareten sind die Stationen mit der höchsten Aktivität, deren Aktivität deutlich über dem Populationsmedian liegt.\n\nMedian <- data %>%\n  summarise(Median = median(gesamt))\nMedian <- Median$Median\n\ndata %>%\n  group_by(zaehlstelle) %>%\n  ggplot(aes(x = zaehlstelle, y = gesamt, fill = zaehlstelle)) +\n  geom_boxplot() +\n  geom_hline(yintercept = Median, linetype=\"dashed\", color = \"black\") + \n  theme_minimal() +\n  theme(axis.title.x=element_blank(),\n        axis.text.x=element_blank(),\n        axis.ticks.x=element_blank()) +\n  ggtitle(\"Boxplots Tagesaktivität per Zählstelle\")"
  },
  {
    "objectID": "posts/Bike_Munich/Bike_Munich.html#wochentage",
    "href": "posts/Bike_Munich/Bike_Munich.html#wochentage",
    "title": "Fahrradaktivität in München (2008-2022)",
    "section": "Wochentage",
    "text": "Wochentage\n\ndata %>%\n  group_by(datum) %>%\n  summarise(Gesamt = sum(gesamt), \n            wday = wday) %>%\n  mutate(wday = case_when(wday == 1 ~ \"Son\",\n                             wday == 2 ~ \"Mo\",\n                             wday == 3 ~ \"Di\",\n                             wday == 4 ~ \"Mi\",\n                             wday == 5 ~ \"Do\",\n                             wday == 6 ~ \"Fr\",\n                             wday == 7 ~ \"Sa\")) %>%\n  distinct() %>%\n  ggplot(aes(x = wday, y = Gesamt, fill = wday)) +\n  geom_boxplot() +\n  geom_hline(yintercept = 7693, linetype=\"dashed\", color = \"black\") + \n  theme_minimal() +\n  theme(axis.title.x=element_blank(),\n        axis.text.x=element_blank(),\n        axis.ticks.x=element_blank()) +\n  ggtitle(\"Boxplots Tagesaktivität per Wochentag\") \n\n\n\n\nAm Wochenende wird weniger Aktivität gemessen. Die Wochenend-mediane liegen unterhalb des Gesamtmedian. Mehr Informationen über die tägliche und Wöchentliche Fahrradaktivität finden sich in dieser Shiny App."
  },
  {
    "objectID": "posts/Bike_Munich/Bike_Munich.html#wetter-und-aktivität",
    "href": "posts/Bike_Munich/Bike_Munich.html#wetter-und-aktivität",
    "title": "Fahrradaktivität in München (2008-2022)",
    "section": "Wetter und Aktivität",
    "text": "Wetter und Aktivität\nSchauen wir uns die Beziehung zwischen dem Wetter und der Fahrradaktivität an.\n\np1 = data %>%\n  group_by(datum) %>%\n  summarise(Gesamt = sum(gesamt), \n            Min.temp = mean(min.temp),\n            saison = saison) %>%\n  distinct() %>%\n  ggplot(aes(x = Min.temp, y = Gesamt)) +\n  geom_point(aes(color = saison), size=0.7) +\n  geom_smooth() +\n  theme_minimal() \n\n\np2 = data %>%\n  group_by(datum) %>%\n  summarise(Gesamt = sum(gesamt), \n            Max.temp = mean(max.temp),\n            saison = saison) %>%\n  distinct() %>%\n  ggplot(aes(x = Max.temp, y = Gesamt)) +\n  geom_point(aes(color = saison), size=0.7, show.legend = FALSE) +\n  geom_smooth() +\n  theme_minimal() \n\np3 = data %>%\n  group_by(datum) %>%\n  summarise(Gesamt = sum(gesamt), \n            Niederschlag = mean(niederschlag),\n            saison = saison) %>%\n  distinct() %>%\n  ggplot(aes(x = Niederschlag, y = Gesamt)) +\n  geom_point(aes(color = saison), size=0.7, show.legend = FALSE) +\n  geom_smooth() +\n  theme_minimal() \n\np4 = data %>%\n  group_by(datum) %>%\n  summarise(Gesamt = sum(gesamt), \n            Bewoelkung = mean(bewoelkung),\n            saison = saison) %>%\n  distinct() %>%\n  ggplot(aes(x = Bewoelkung, y = Gesamt)) +\n  geom_point(aes(color = saison), size=0.7, show.legend = FALSE) +\n  geom_smooth() +\n  theme_minimal() \n\np5 = data %>%\n  group_by(datum) %>%\n  summarise(Gesamt = sum(gesamt), \n            Sonnenstunden = mean(sonnenstunden),\n            saison = saison) %>%\n  distinct() %>%\n  ggplot(aes(x = Sonnenstunden, y = Gesamt)) +\n  geom_point(aes(color = saison), size=0.7, show.legend = FALSE) +\n  geom_smooth() +\n  theme_minimal() \n\n\nggarrange(p1, p2, p4, p5, p3,\n          ncol = 2, nrow = 3, common.legend = TRUE)\n\n\n\n\nMin und Max Temperatur sind positiv mit der Aktivität assoziiert. Das Verhältnis scheint dabei linear zu sein. D.h. dass eine Temperaturerhöhung um n Grad ungefähr eine Aktivitätssteigerung um x Fahrradfahrerinnen mit sich bringt. Ähnliches gilt für Sonnenstunden. Bei der Bewölkung haben wir eine negative Assoziation.\nAuf den ersten Blick scheint die Stärke des Niederschlags keinen besonderen Einfluss auf Fahrradaktivität zu haben. Das liegt vielleicht daran, dass es in München generell wenig regnet und der Trend durch große Regen-Ausreißer verzerrt wird. Beschränken wir die Observation auf das 95% Quantil der Regen Daten.\n\nquantile(data$niederschlag, probs = 0.95)\n\n\ndata %>%\n  group_by(datum) %>%\n  filter(niederschlag <= 12.1 ) %>%\n  summarise(Gesamt = sum(gesamt), \n            Niederschlag = mean(niederschlag)) %>%\n  distinct() %>%\n  ggplot(aes(x = Niederschlag, y = Gesamt)) +\n  geom_point(shape = 15, size = 2) +\n  geom_smooth() +\n  theme_minimal() +\n  labs(title = \"Niederschlag und Aktivität\",\n       subtitle = \"Beschränkt auf das 95% Quantil\")\n\n\n\n\nBei kleinen Werten scheint es einen leichten negativen Trend zu geben. Allgemein betrachtet ist der Trend jedoch schwachen."
  },
  {
    "objectID": "posts/Bike_Munich/Bike_Munich.html#regression",
    "href": "posts/Bike_Munich/Bike_Munich.html#regression",
    "title": "Fahrradaktivität in München (2008-2022)",
    "section": "Regression",
    "text": "Regression\nEin einfaches Model für das Verständnis der Einflussfaktoren ist die lineare Regression:\n\nmodel <- lm(gesamt ~ min.temp + niederschlag + bewoelkung + sonnenstunden + wday, data = data )\n\n\n\nplot_summs(model)\n\n\n\n\nWir sehen, dass die Sonnenstunden den größten Einfluss auf die Tagesaktivität hat. Noch größer als die Temperatur. Je sonniger es in München ist, desto mehr wird an den Stationen gemessen.\nInteressanterweise scheint Niederschlag nun einen signifikanten negativen Einfluss auf die Aktivität zu haben. Das dieses Verhältnis vorher nicht aufgefallen ist mag vielleicht daran gelegen haben, dass Niederschlag positiv mit dem positiven Einflussfaktor Temperatur korreliert ist und der negative Effekt dadurch übertüncht wurde."
  }
]